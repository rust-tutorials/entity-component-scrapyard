<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Creating our struct - entity-component-scrapyard</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02-Entities/generator.html"><strong aria-hidden="true">2.</strong> A basic entity generator</a></li><li class="chapter-item expanded "><a href="../03-Archetypes/summary.html"><strong aria-hidden="true">3.</strong> Archetypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-Archetypes/archetype-explanation.html"><strong aria-hidden="true">3.1.</strong> What are archetypes?</a></li><li class="chapter-item expanded "><a href="../03-Archetypes/archetype-struct.html" class="active"><strong aria-hidden="true">3.2.</strong> Creating our struct</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">entity-component-scrapyard</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="creating-our-struct"><a class="header" href="#creating-our-struct">Creating our struct</a></h1>
<p>Before we get started, in our <code>src/lib.rs</code> file we should add <code>mod archetype;</code> and then make a 
file at <code>src/archetype.rs</code>. All of the code in this chapter will be inside of this <code>archetype.rs</code> file</p>
<p>Our archetype struct needs to be able to store any number of component columns. The
way to do this normally would be a <code>Vec&lt;ComponentColumn&gt;</code> however our component columns
are going to be Vec's which are generic over the type they store. This is a bit problematic
for since we want to store a set of things that aren't the same type</p>
<p>Luckily rust has a way of yeeting type information away- trait objects. We can implement a trait
for every type of Vec and then store a <code>Vec&lt;Box&lt;dyn TypeErasedVec&gt;&gt;</code>. We can then downcase the 
trait object back to a concrete type whenever we need to. e.g. when we add/remove components</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::Any;

trait ComponentColumn: Any {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;
}

impl&lt;T: 'static&gt; ComponentColumn for Vec&lt;T&gt; {
    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {
        self
    }
}

struct Archetype {
    entities: Vec&lt;crate::Entity&gt;,
    columns: Vec&lt;Box&lt;dyn ComponentColumn&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we define our <code>ComponentColumn</code> trait to be a supertrait of the <code>Any</code> trait. You might not
have come across the <code>Any</code> trait before, it doesn't tend to come up very often when writing rust.
The general idea behind the <code>Any</code> trait is that we cast a type to a trait object and then call
<code>downcast_ref/mut</code> with a generic to turn it back into a concrete type. 
You can see the docs for std::any::Any <a href="https://doc.rust-lang.org/std/any/trait.Any.html">here</a></p>
<h2 id="methods-for-creating-an-instance-of-our-archetype-struct"><a class="header" href="#methods-for-creating-an-instance-of-our-archetype-struct">Methods for creating an instance of our Archetype struct</a></h2>
<p>We need some methods for creating instances of our <code>Archetype</code> struct. There are two situations that
we'll be needing to create an <code>Archetype</code> in:</p>
<ul>
<li>When we add/remove a component we'll have to create the archetype that we need to move the entity to</li>
<li>When we spawn an entity we'll have to create an archetype matching the component's given</li>
</ul>
<p>We'll start with the add/remove situation because that's going to be easier to write.</p>
<p>The first thing we want to do is make a method on our <code>ComponentColumn</code> trait that returns a 
<code>Box&lt;dyn ComponentColumn&gt;</code> of the same type of Vec. This will let us create an archetype with the same
set of columns as an existing one. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ComponentColumn: Any {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;
    fn new_empty_column(&amp;self) -&gt; Box&lt;dyn ComponentColumn&gt;;
}

impl&lt;T: 'static&gt; ComponentColumn for Vec&lt;T&gt; {
    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {
        self
    }

    fn new_empty_column(&amp;self) -&gt; Box&lt;dyn ComponentColumn&gt; {
        Box::new(Vec::&lt;T&gt;::new())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now lets look at the method for creating the archetype we want to move our entity to after an add/remove op: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Archetype {
    fn new_from_add&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
        let mut columns: Vec&lt;_&gt; = from_archetype
            .columns
            .iter()
            .map(|column| column.new_empty_column())
            .collect();

        todo!(&quot;Actually add the column&quot;);

        Archetype {
            entities: Vec::new(),
            columns,
        }
    }

    fn new_from_remove&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
        let mut columns: Vec&lt;_&gt; = from_archetype
            .columns
            .iter()
            .map(|column| column.new_empty_column())
            .collect();

        todo!(&quot;Actually remove the column&quot;);

        Archetype {
            entities: Vec::new(),
            columns,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We could *technically* merge these into one method and choose whether to add or remove
depending on whether <code>Vec&lt;T&gt;</code> is already present in the columns. However whenever we call
this method we'll *know* whether it's meant to be an add/remove, so if we make them separate
methods we can add some checks that it's valid to add/remove a component from the archetype.</p>
<p>The code for <code>new_from_add</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Archetype {
    fn new_from_add&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
<span class="boring">       let mut columns: Vec&lt;_&gt; = from_archetype
</span><span class="boring">           .columns
</span><span class="boring">           .iter()
</span><span class="boring">           .map(|column| column.new_empty_column())
</span><span class="boring">           .collect();
</span>        /* snip */

        assert!(columns
            .iter()
            .position(|column| column.as_any().is::&lt;Vec&lt;T&gt;&gt;())
            .is_none());
        columns.push(Box::new(Vec::&lt;T&gt;::new()));

        /* snip */
<span class="boring">       Archetype {
</span><span class="boring">           entities: Vec::new(),
</span><span class="boring">           columns,
</span><span class="boring">       }
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We just <code>assert!</code> here instead of trying to recover because it's going to be a bug in our ECS if 
this assert fires and we really want that to happen loudly.</p>
<p>The code for <code>new_from_remove</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new_from_remove&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
<span class="boring">       let mut columns: Vec&lt;_&gt; = from_archetype
</span><span class="boring">           .columns
</span><span class="boring">           .iter()
</span><span class="boring">           .map(|column| column.new_empty_column())
</span><span class="boring">           .collect();
</span>        /* snip */

        let idx = columns
            .iter()
            .position(|column| column.as_any().is::&lt;Vec&lt;T&gt;&gt;()).unwrap();
        columns.remove(idx);

        /* snip */
<span class="boring">       Archetype {
</span><span class="boring">           entities: Vec::new(),
</span><span class="boring">           columns,
</span><span class="boring">       }
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p>Same reason as above for why we just panic in here rather than try to recover :)</p>
<p>That should be everything we need for these two functions but before we
move on lets add some tests to verify everything is working correctly</p>
<h2 id="tests-for-addremove-constructors"><a class="header" href="#tests-for-addremove-constructors">Tests for add/remove constructors</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    /* todo tests */
}
<span class="boring">}
</span></code></pre></pre>
<p>First tests we should add are some simple ones for testing those asserts/unwraps 
fire when trying to call <code>new_from_(add/remove)</code> on incorrect archetypes.</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::any::Any;
</span><span class="boring">
</span><span class="boring">trait ComponentColumn: Any {
</span><span class="boring">    fn as_any(&amp;self) -&gt; &amp;dyn Any;
</span><span class="boring">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;
</span><span class="boring">    fn new_empty_column(&amp;self) -&gt; Box&lt;dyn ComponentColumn&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: 'static&gt; ComponentColumn for Vec&lt;T&gt; {
</span><span class="boring">    fn as_any(&amp;self) -&gt; &amp;dyn Any {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_empty_column(&amp;self) -&gt; Box&lt;dyn ComponentColumn&gt; {
</span><span class="boring">        Box::new(Vec::&lt;T&gt;::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Archetype {
</span><span class="boring">    entities: Vec&lt;crate::Entity&gt;,
</span><span class="boring">    columns: Vec&lt;Box&lt;dyn ComponentColumn&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Archetype {
</span><span class="boring">    fn new_from_add&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
</span><span class="boring">        let mut columns: Vec&lt;_&gt; = from_archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|column| column.new_empty_column())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        assert!(columns
</span><span class="boring">            .iter()
</span><span class="boring">            .position(|column| column.as_any().is::&lt;Vec&lt;T&gt;&gt;())
</span><span class="boring">            .is_none());
</span><span class="boring">        columns.push(Box::new(Vec::&lt;T&gt;::new()));
</span><span class="boring">
</span><span class="boring">        Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_from_remove&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
</span><span class="boring">        let mut columns: Vec&lt;_&gt; = from_archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|column| column.new_empty_column())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let idx = columns
</span><span class="boring">            .iter()
</span><span class="boring">            .position(|column| column.as_any().is::&lt;Vec&lt;T&gt;&gt;())
</span><span class="boring">            .unwrap();
</span><span class="boring">        columns.remove(idx);
</span><span class="boring">
</span><span class="boring">        Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn builder() -&gt; ColumnsBuilder {
</span><span class="boring">        ColumnsBuilder(Vec::new())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_from_columns(columns: ColumnsBuilder) -&gt; Archetype {
</span><span class="boring">        Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns: columns.0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ColumnsBuilder(Vec&lt;Box&lt;dyn ComponentColumn&gt;&gt;);
</span><span class="boring">
</span><span class="boring">impl ColumnsBuilder {
</span><span class="boring">    fn with_column_type&lt;T: 'static&gt;(mut self) -&gt; Self {
</span><span class="boring">        if let Some(_) = self
</span><span class="boring">            .0
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|col| col.as_any().type_id() == std::any::TypeId::of::&lt;Vec&lt;T&gt;&gt;())
</span><span class="boring">            .next()
</span><span class="boring">        {
</span><span class="boring">            panic!(&quot;Attempted to create invalid archetype&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        self.0.push(Box::new(Vec::&lt;T&gt;::new()));
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_removes() {
</span><span class="boring">        let archetype = Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns: Vec::new(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let archetype = Archetype::new_from_add::&lt;u32&gt;(&amp;archetype);
</span><span class="boring">        assert!(archetype.columns.len() == 1);
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">
</span><span class="boring">        let archetype = Archetype::new_from_add::&lt;u64&gt;(&amp;archetype);
</span><span class="boring">        assert!(archetype.columns.len() == 2);
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">
</span><span class="boring">        let archetype = Archetype::new_from_remove::&lt;u32&gt;(&amp;archetype);
</span><span class="boring">        assert!(archetype.columns.len() == 1);
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    #[should_panic]
    fn add_preexisting() {
        let archetype = Archetype {
            entities: Vec::new(),
            columns: Vec::new(),
        };
        let archetype = Archetype::new_from_add::&lt;u32&gt;(&amp;archetype);
        let archetype = Archetype::new_from_add::&lt;u32&gt;(&amp;archetype);
    }

    #[test]
    #[should_panic]
    fn remove_unpresent() {
        let archetype = Archetype {
            entities: Vec::new(),
            columns: Vec::new(),
        };
        let archetype = Archetype::new_from_remove::&lt;u32&gt;(&amp;archetype);
    }

    #[test]
    #[should_panic]
    fn remove_unpresent_2() {
        let archetype = Archetype {
            entities: Vec::new(),
            columns: Vec::new(),
        };
        let archetype = Archetype::new_from_add::&lt;u64&gt;(&amp;archetype);
        let archetype = Archetype::new_from_remove::&lt;u32&gt;(&amp;archetype);
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn columns_builder() {
</span><span class="boring">        let archetype = Archetype::new_from_columns(
</span><span class="boring">            Archetype::builder()
</span><span class="boring">                .with_column_type::&lt;u32&gt;()
</span><span class="boring">                .with_column_type::&lt;u64&gt;()
</span><span class="boring">                .with_column_type::&lt;bool&gt;(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        assert!(archetype.columns.len() == 3);
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;bool&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn columns_builder_duplicate() {
</span><span class="boring">        let archetype = Archetype::new_from_columns(
</span><span class="boring">            Archetype::builder()
</span><span class="boring">                .with_column_type::&lt;u32&gt;()
</span><span class="boring">                .with_column_type::&lt;u32&gt;(),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The next test we want is just something to call <code>new_from_(add/remove)</code> a bunch and assert
that all the columns that we expect to be present are actually present:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::any::Any;
</span><span class="boring">
</span><span class="boring">trait ComponentColumn: Any {
</span><span class="boring">    fn as_any(&amp;self) -&gt; &amp;dyn Any;
</span><span class="boring">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;
</span><span class="boring">    fn new_empty_column(&amp;self) -&gt; Box&lt;dyn ComponentColumn&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: 'static&gt; ComponentColumn for Vec&lt;T&gt; {
</span><span class="boring">    fn as_any(&amp;self) -&gt; &amp;dyn Any {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_empty_column(&amp;self) -&gt; Box&lt;dyn ComponentColumn&gt; {
</span><span class="boring">        Box::new(Vec::&lt;T&gt;::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Archetype {
</span><span class="boring">    entities: Vec&lt;crate::Entity&gt;,
</span><span class="boring">    columns: Vec&lt;Box&lt;dyn ComponentColumn&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Archetype {
</span><span class="boring">    fn new_from_add&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
</span><span class="boring">        let mut columns: Vec&lt;_&gt; = from_archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|column| column.new_empty_column())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        assert!(columns
</span><span class="boring">            .iter()
</span><span class="boring">            .position(|column| column.as_any().is::&lt;Vec&lt;T&gt;&gt;())
</span><span class="boring">            .is_none());
</span><span class="boring">        columns.push(Box::new(Vec::&lt;T&gt;::new()));
</span><span class="boring">
</span><span class="boring">        Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_from_remove&lt;T: 'static&gt;(from_archetype: &amp;Archetype) -&gt; Archetype {
</span><span class="boring">        let mut columns: Vec&lt;_&gt; = from_archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|column| column.new_empty_column())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let idx = columns
</span><span class="boring">            .iter()
</span><span class="boring">            .position(|column| column.as_any().is::&lt;Vec&lt;T&gt;&gt;())
</span><span class="boring">            .unwrap();
</span><span class="boring">        columns.remove(idx);
</span><span class="boring">
</span><span class="boring">        Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn builder() -&gt; ColumnsBuilder {
</span><span class="boring">        ColumnsBuilder(Vec::new())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_from_columns(columns: ColumnsBuilder) -&gt; Archetype {
</span><span class="boring">        Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns: columns.0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ColumnsBuilder(Vec&lt;Box&lt;dyn ComponentColumn&gt;&gt;);
</span><span class="boring">
</span><span class="boring">impl ColumnsBuilder {
</span><span class="boring">    fn with_column_type&lt;T: 'static&gt;(mut self) -&gt; Self {
</span><span class="boring">        if let Some(_) = self
</span><span class="boring">            .0
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|col| col.as_any().type_id() == std::any::TypeId::of::&lt;Vec&lt;T&gt;&gt;())
</span><span class="boring">            .next()
</span><span class="boring">        {
</span><span class="boring">            panic!(&quot;Attempted to create invalid archetype&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        self.0.push(Box::new(Vec::&lt;T&gt;::new()));
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn add_removes() {
        let archetype = Archetype {
            entities: Vec::new(),
            columns: Vec::new(),
        };

        let archetype = Archetype::new_from_add::&lt;u32&gt;(&amp;archetype);
        assert!(archetype.columns.len() == 1);
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
            .is_some());

        let archetype = Archetype::new_from_add::&lt;u64&gt;(&amp;archetype);
        assert!(archetype.columns.len() == 2);
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
            .is_some());
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
            .is_some());

        let archetype = Archetype::new_from_remove::&lt;u32&gt;(&amp;archetype);
        assert!(archetype.columns.len() == 1);
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
            .is_some());
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn add_preexisting() {
</span><span class="boring">        let archetype = Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns: Vec::new(),
</span><span class="boring">        };
</span><span class="boring">        let archetype = Archetype::new_from_add::&lt;u32&gt;(&amp;archetype);
</span><span class="boring">        let archetype = Archetype::new_from_add::&lt;u32&gt;(&amp;archetype);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn remove_unpresent() {
</span><span class="boring">        let archetype = Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns: Vec::new(),
</span><span class="boring">        };
</span><span class="boring">        let archetype = Archetype::new_from_remove::&lt;u32&gt;(&amp;archetype);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn remove_unpresent_2() {
</span><span class="boring">        let archetype = Archetype {
</span><span class="boring">            entities: Vec::new(),
</span><span class="boring">            columns: Vec::new(),
</span><span class="boring">        };
</span><span class="boring">        let archetype = Archetype::new_from_add::&lt;u64&gt;(&amp;archetype);
</span><span class="boring">        let archetype = Archetype::new_from_remove::&lt;u32&gt;(&amp;archetype);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn columns_builder() {
</span><span class="boring">        let archetype = Archetype::new_from_columns(
</span><span class="boring">            Archetype::builder()
</span><span class="boring">                .with_column_type::&lt;u32&gt;()
</span><span class="boring">                .with_column_type::&lt;u64&gt;()
</span><span class="boring">                .with_column_type::&lt;bool&gt;(),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        assert!(archetype.columns.len() == 3);
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">        assert!(archetype
</span><span class="boring">            .columns
</span><span class="boring">            .iter()
</span><span class="boring">            .find(|col| col.as_any().is::&lt;Vec&lt;bool&gt;&gt;())
</span><span class="boring">            .is_some());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn columns_builder_duplicate() {
</span><span class="boring">        let archetype = Archetype::new_from_columns(
</span><span class="boring">            Archetype::builder()
</span><span class="boring">                .with_column_type::&lt;u32&gt;()
</span><span class="boring">                .with_column_type::&lt;u32&gt;(),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<h2 id="archetype-constructor-for-when-spawning-entities"><a class="header" href="#archetype-constructor-for-when-spawning-entities">Archetype constructor for when spawning entities</a></h2>
<p>Now that we've finished up the constructors for when we add/remove components on an entity we
need to make one for when we spawn an entity and need to build an archetype for it.</p>
<p>This one is a bit tricker because we want to take any # of component types when we create an
archetype to spawn our entity into. We'll want some kind of builder struct that we can repeatedly
call a function on to add component columns.</p>
<p>Something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ColumnsBuilder(Vec&lt;Box&lt;dyn ComponentColumn&gt;&gt;);

impl ColumnsBuilder {
    fn with_column_type&lt;T: 'static&gt;(mut self) -&gt; Self {
        if let Some(_) = self
            .0
            .iter()
            .filter(|col| col.as_any().type_id() == std::any::TypeId::of::&lt;Vec&lt;T&gt;&gt;())
            .next()
        {
            panic!(&quot;Attempted to create invalid archetype&quot;);
        }

        self.0.push(Box::new(Vec::&lt;T&gt;::new()));
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We have to check that we don't try to create an archetype with two columns for the same component
type. i.e. an archetype for entities with components <code>[T, T]</code> is nonsensical as an entity cannot
have the same component added twice. Currently I just panic here if we detect that but it would 
be possible to return a <code>Result</code> here and propagate it up to the user</p>
<p>Now that we have a <code>ColumnsBuilder</code> lets add some methods to <code>Archetype</code> to use it</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Archetype {
    /* snip */

    fn builder() -&gt; ColumnsBuilder {
        ColumnsBuilder(Vec::new())
    }

    fn new_from_columns(columns: ColumnsBuilder) -&gt; Archetype {
        Archetype {
            entities: Vec::new(),
            columns: columns.0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>An alternative way of implementing this would be to implement a trait for tuples of length 1 to 
some arbitrary limit and then create the columns in that trait. This has the downside of needing
to use macros for the trait impl and we also would have a limit on how many components could be
spawned on an entity without adding components separately. (We'll doing something like this later
on when we implement iterators over our archetypes)</p>
<p>This should be us done with the method we'll use when creating an <code>Archetype</code> to spawn an entity
into, we just need to add some tests before moving on :)</p>
<h2 id="tests-for-columnsbuilder"><a class="header" href="#tests-for-columnsbuilder">Tests for ColumnsBuilder</a></h2>
<p>We'll want a test that our duplicate column checks work and also a general test that we have the
expected columns after building an archetype from the <code>ColumnsBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    /* snip */

    #[test]
    fn columns_builder() {
        let archetype = Archetype::new_from_columns(
            Archetype::builder()
                .with_column_type::&lt;u32&gt;()
                .with_column_type::&lt;u64&gt;()
                .with_column_type::&lt;bool&gt;(),
        );

        assert!(archetype.columns.len() == 3);
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;u32&gt;&gt;())
            .is_some());
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;u64&gt;&gt;())
            .is_some());
        assert!(archetype
            .columns
            .iter()
            .find(|col| col.as_any().is::&lt;Vec&lt;bool&gt;&gt;())
            .is_some());
    }

    #[test]
    #[should_panic]
    fn columns_builder_duplicate() {
        let archetype = Archetype::new_from_columns(
            Archetype::builder()
                .with_column_type::&lt;u32&gt;()
                .with_column_type::&lt;u32&gt;(),
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The full source code for this chapter can be viewed <a href="https://github.com/rust-tutorials/entity-component-scrapyard/tree/main/Book/03-Archetypes/code">here</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../03-Archetypes/archetype-explanation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../03-Archetypes/archetype-explanation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
